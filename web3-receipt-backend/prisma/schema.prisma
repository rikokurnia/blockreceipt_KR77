// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 1. ENUMS (Digabung Phase 1 & 2)
enum Role {
  auditor
  cfo
  finance_admin // NEW
  vendor        // NEW
}

enum ReceiptStatus {
  pending
  processing
  verified
  failed
  pending_approval // NEW
  rejected         // NEW
}

enum AgreementStatus {
  draft
  pending_vendor   
  pending_cfo      
  active           
  rejected
  expired
}

enum ProofType {
  between
  less_than
  greater_than
  equals
}

enum ZKStatus {
  valid
  expired
  revoked
}

// 2. USER MODEL

model User {
  id                String   @id @default(uuid()) // @db.Uuid dihapus (MySQL pake String biasa)
  wallet_address    String   @unique
  role              Role
  organization_name String?
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  // Phase 1 Relations
  receipts          Receipt[]
  zk_proofs         ZKProof[]
  
  // Phase 2 Relations
  created_agreements Agreement[]   @relation("AgreementCreator")
  approvals          ApprovalLog[] @relation("Approver")

  @@map("users")
}

// 3. PHASE 2 MODELS (AGREEMENT & VENDOR)

model Vendor {
  id          String   @id @default(uuid())
  name        String
  email       String?
  phone       String?
  address     String?
  created_at  DateTime @default(now())
  
  agreements  Agreement[]

  @@map("vendors")
}

model Agreement {
  id              String          @id // Manual ID: AGR-2025-xxxx
  
  vendor_id       String          
  vendor          Vendor          @relation(fields: [vendor_id], references: [id])
  
  category_id     String          
  category        Category        @relation(fields: [category_id], references: [id])
  
  title           String
  start_date      DateTime        @db.Date
  end_date        DateTime        @db.Date
  payment_terms   String
  
  total_value     Decimal         @db.Decimal(18, 2)
  status          AgreementStatus @default(draft)
  
  tx_hash         String?
  
  created_by      String          
  user            User            @relation("AgreementCreator", fields: [created_by], references: [id])
  
  created_at      DateTime        @default(now())
  updated_at      DateTime        @updatedAt

  items           AgreementItem[]

  @@map("agreements")
}

model AgreementItem {
  id            String    @id @default(uuid())
  agreement_id  String
  agreement     Agreement @relation(fields: [agreement_id], references: [id])
  
  item_name     String
  specifications String?  @db.Text
  quantity      Int
  unit_price    Decimal   @db.Decimal(18, 2)
  subtotal      Decimal   @db.Decimal(18, 2)

  @@map("agreement_items")
}

// 4. FINANCIAL CONTROL MODELS

model Category {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  is_active   Boolean  @default(true)
  created_at  DateTime @default(now())

  // Relations
  receipts      Receipt[]
  zk_categories ZKProofCategory[]
  agreements    Agreement[]
  daily_limit   DailyLimit?

  @@map("categories")
}

model DailyLimit {
  id            String    @id @default(uuid())
  category_id   String    @unique
  category      Category  @relation(fields: [category_id], references: [id])
  
  limit_amount  Decimal   @db.Decimal(18, 2)
  updated_at    DateTime  @updatedAt

  @@map("daily_limits")
}

model ApprovalLog {
  id            String    @id @default(uuid())
  receipt_id    String?   
  agreement_id  String?   
  
  approver_id   String    
  approver      User      @relation("Approver", fields: [approver_id], references: [id])
  
  role_at_time  Role
  action        String    
  notes         String?
  timestamp     DateTime  @default(now())

  @@map("approval_logs")
}

// 5. PHASE 1 MODELS (RECEIPT & BLOCKCHAIN)

model Receipt {
  id                   String        @id 
  user_id              String        
  user                 User          @relation(fields: [user_id], references: [id])
  
  category_id          String        
  category             Category      @relation(fields: [category_id], references: [id])
  
  vendor_name          String
  invoice_number       String?
  receipt_date         DateTime      @db.Date
  
  subtotal             Decimal       @db.Decimal(18, 2)
  tax_amount           Decimal       @db.Decimal(18, 2)
  total_amount         Decimal       @db.Decimal(18, 2)
  extracted_total      Decimal?      @db.Decimal(18, 2)
  
  notes                String?
  status               ReceiptStatus @default(pending)
  
  ai_confidence_score  Float
  ai_confidence_reason String?
  is_manually_verified Boolean       @default(false)
  
  created_at           DateTime      @default(now())
  updated_at           DateTime      @updatedAt

  items                ReceiptItem[]
  blockchain_record    BlockchainRecord?
  ipfs_record          IPFSRecord?

  @@map("receipts")
}

model ReceiptItem {
  id          String   @id @default(uuid())
  receipt_id  String
  receipt     Receipt  @relation(fields: [receipt_id], references: [id])
  
  description String
  quantity    Int
  unit_price  Decimal  @db.Decimal(18, 2)
  total       Decimal  @db.Decimal(18, 2)
  sequence    Int

  @@map("receipt_items")
}

model BlockchainRecord {
  id           String   @id @default(uuid())
  receipt_id   String   @unique
  receipt      Receipt  @relation(fields: [receipt_id], references: [id])
  
  tx_hash      String
  block_number BigInt
  network      String
  recorded_at  DateTime @default(now())

  @@map("blockchain_records")
}

model IPFSRecord {
  id          String   @id @default(uuid())
  receipt_id  String   @unique
  receipt     Receipt  @relation(fields: [receipt_id], references: [id])
  
  cid         String
  file_hash   String?
  file_size   BigInt?
  file_type   String?
  uploaded_at DateTime @default(now())

  @@map("ipfs_records")
}

// 6. ZK PROOF MODELS

model ZKProof {
  id                   String    @id 
  user_id              String    
  user                 User      @relation(fields: [user_id], references: [id])
  
  name                 String
  purpose              String?
  date_range_start     DateTime  @db.Date
  date_range_end       DateTime  @db.Date
  
  proof_type           ProofType
  range_min            Decimal   @db.Decimal(18, 2)
  range_max            Decimal   @db.Decimal(18, 2)
  
  actual_amount_encrypted Bytes? 
  actual_amount_hash      String?
  
  proof_metadata       Json?     
  include_categories   Boolean   @default(false)
  status               ZKStatus  @default(valid)
  is_public            Boolean   @default(true)
  
  proof_hash           String
  verification_count   Int       @default(0)
  
  last_verified_at     DateTime?
  created_at           DateTime  @default(now())
  expires_at           DateTime

  categories           ZKProofCategory[]
  verification_logs    ZKVerificationLog[]
  blockchain_record    ZKProofBlockchain?

  @@map("zk_proofs")
}

model ZKProofCategory {
  id          String   @id @default(uuid())
  zk_proof_id String
  zk_proof    ZKProof  @relation(fields: [zk_proof_id], references: [id])
  
  category_id String   
  category    Category @relation(fields: [category_id], references: [id])

  @@map("zk_proof_categories")
}

model ZKProofBlockchain {
  id           String   @id @default(uuid())
  zk_proof_id  String   @unique
  zk_proof     ZKProof  @relation(fields: [zk_proof_id], references: [id])
  
  tx_hash      String
  block_number BigInt
  recorded_at  DateTime @default(now())

  @@map("zk_proof_blockchain")
}

model ZKVerificationLog {
  id                  String   @id @default(uuid())
  zk_proof_id         String
  zk_proof            ZKProof  @relation(fields: [zk_proof_id], references: [id])
  
  verifier_ip_hash    String
  verifier_user_agent String?
  verified_at         DateTime @default(now())

  @@map("zk_verification_logs")
}